using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using MauiApp1.DependencyInjection.ComponentModel;

namespace MauiApp1.DependencyInjection.SourceGenerators;

[Generator]
internal class ServiceRegistrationSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a provider which targets classes that have at least one attribute.
        // We will check which attribute it is during the actual code generation phase.
        var provider = context.SyntaxProvider.CreateSyntaxProvider(
            predicate: static (node, cancellationToken) =>
            {
                if (node is ClassDeclarationSyntax classNode)
                {
                    foreach (var attributeList in classNode.AttributeLists)
                    {
                        if (attributeList.Attributes.Count > 0)
                        {
                            return true;
                        }
                    }
                }

                return false;
            },
            transform: static (context, cancellationToken) => context.Node as ClassDeclarationSyntax
            ).Where(node => node is not null);

        var compilation = context.CompilationProvider.Combine(provider.Collect());

        context.RegisterSourceOutput(compilation, Execute);
    }

    void Execute(SourceProductionContext context, (Compilation Left, ImmutableArray<ClassDeclarationSyntax?> Right) tuple)
    {
        // Deconstruct the tuple.
        var (compilation, classDeclarationSyntaxNodes) = tuple;

        // Iterate over the data and collect the service registration code.
        StringBuilder serviceRegistrationStringBuilder = new();
        foreach (var classDeclarationSyntax in classDeclarationSyntaxNodes)
        {
            if (classDeclarationSyntax is null)
            {
                continue;
            }

            var serviceRegistrationCode = GenerateServiceRegistrationCode(compilation, classDeclarationSyntax);
            if (!string.IsNullOrWhiteSpace(serviceRegistrationCode))
            {
                serviceRegistrationStringBuilder
                    .Append("        ").AppendLine(serviceRegistrationCode);
            }
        }

        // Trim the end.
        //serviceRegistrationStringBuilder.TrimEnd('\n', '\r');

        var code = $$"""
            // <auto-generated/>

            namespace MauiApp1.DependencyInjection;
            
            public static class MauiAppBuilderExtensions
            {
                public static MauiAppBuilder UseSourceGeneratedServiceRegistration(this MauiAppBuilder builder)
                {
            {{serviceRegistrationStringBuilder}}
                    return builder;
                }
            }
            """;

        context.AddSource("MauiAppBuilderExtensions.g.cs", code);
    }

    string? GenerateServiceRegistrationCode(Compilation compilation, ClassDeclarationSyntax classDeclaration)
    {
        // The attributes we are looking for.
        var scopedAttributeSymbol = compilation.GetTypeByMetadataName(typeof(ScopedAttribute).FullName);
        var singletonAttributeSymbol = compilation.GetTypeByMetadataName(typeof(SingletonAttribute).FullName);
        var transientAttributeSymbol = compilation.GetTypeByMetadataName(typeof(TransientAttribute).FullName);

        // We need the semantic model to safely check the attributes.
        var semanticModel = compilation.GetSemanticModel(classDeclaration.SyntaxTree);

        foreach (var list in classDeclaration.AttributeLists)
        {
            foreach (var attribute in list.Attributes)
            {
                // Get information about the attribute.
                var attributeTypeInfo = semanticModel.GetTypeInfo(attribute);
                var attributeType = attributeTypeInfo.Type;

                if (attributeType is null)
                {
                    continue;
                }

                //if (!Debugger.IsAttached)
                //{
                //    Debugger.Launch();
                //}

                string? serviceRegistrationMethodName = null;

                if (IsAttributeOrDerivedFrom(attributeType, scopedAttributeSymbol))
                {
                    serviceRegistrationMethodName = "AddScoped";
                }
                else if (IsAttributeOrDerivedFrom(attributeType, singletonAttributeSymbol))
                {
                    serviceRegistrationMethodName = "AddSingleton";
                }
                else if (IsAttributeOrDerivedFrom(attributeType, transientAttributeSymbol))
                {
                    serviceRegistrationMethodName = "AddTransient";
                }

                // If we have no value here it means that none of the attributes matched.
                if (serviceRegistrationMethodName is null)
                    continue;

                // Get the implementation's full name (the class decorated with the attribute).
                var implementationFullName = GetFullyQualifiedName(semanticModel, classDeclaration);
                if (implementationFullName is null)
                {
                    return null;
                }

                // Get the service's full name from the type arguments, otherwise set it to the implementation's.
                var serviceTypeFullName = GetFullyQualifiedName(((INamedTypeSymbol)attributeType).TypeArguments.FirstOrDefault());// ?? implementationFullName;

                // Get the service key, if any.
                var serviceKeyText = GetServiceKeyTextFromAttribute(attribute);
                if (serviceKeyText is not null)
                {
                    serviceRegistrationMethodName = serviceRegistrationMethodName.Replace("Add", "AddKeyed");
                }

                // Return the code line.
                if (serviceTypeFullName is null)
                {
                    return $"builder.Services.{serviceRegistrationMethodName}<{implementationFullName}>({serviceKeyText});";
                }
                else
                {
                    return $"builder.Services.{serviceRegistrationMethodName}<{serviceTypeFullName}, {implementationFullName}>({serviceKeyText});";
                }
            }
        }

        return null;
    }

    static string? GetFullyQualifiedName(ISymbol? symbol)
    {
        if (symbol is null)
        {
            return null;
        }

        return symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    static string? GetFullyQualifiedName(SemanticModel semanticModel, BaseTypeDeclarationSyntax? declarationSyntax)
    {
        if (declarationSyntax is null)
        {
            return null;
        }

        var symbol = semanticModel.GetDeclaredSymbol(declarationSyntax);
        if (symbol is null)
        {
            return null;
        }

        return symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }

    static string? GetServiceKeyTextFromAttribute(AttributeSyntax attributeSyntax)
    {
        var serviceKeyArgument = attributeSyntax.ArgumentList?.Arguments.FirstOrDefault();
        if (serviceKeyArgument is null)
            return null;

        var expression = serviceKeyArgument.Expression as LiteralExpressionSyntax;
        if (expression is null || expression.Token.IsKind(SyntaxKind.NullKeyword))
            return null;

        return (string?)expression.Token.Text;
    }

    static bool IsAttributeOrDerivedFrom(ITypeSymbol? attributeSymbol, INamedTypeSymbol? baseAttributeSymbol)
    {
        if (baseAttributeSymbol is null)
        {
            return false;
        }

        // Check if the attribute or any of its base types match the base attribute
        while (attributeSymbol is not null)
        {
            if (SymbolEqualityComparer.Default.Equals(attributeSymbol, baseAttributeSymbol))
            {
                return true;
            }

            attributeSymbol = attributeSymbol.BaseType;
        }

        return false;
    }
}
